#!/usr/bin/env python3
"""
This is a python script that is parsing the .txt files, 
generated by the CO2 sensing device. It automatically 
finds areas of intrest, classifies the measurments as 
long/short measurments (i.e. transparent or dark covers) 
performs some cosmetic formating and exports the result
in a .xlsx sheet.
"""

import pandas as pd
import numpy as np
import sys
import os
import argparse


#converts incoming strings to integers
def comma_to_int(x):
    try:
        return int(float(x.replace(',','.')))
    except:
        return -1


#converts incoming strings to floats
def comma_to_float(x):
    try:
        return float(x.replace(',','.'))
    except:
        return 0.0
    
#Reads the file
#   Parameters:
#       path:string
#       path to the file that should be read
#   Returns:
#       content:pandas Data Frame
#       Dataframe containing the Data. If nescessary string numbers 
#       have been converted to integer/float.
def read_file(path):
    
    #imports the file
    content = pd.read_csv(path,
                          delimiter='\t',
                          skiprows = [1,2],
                          index_col = False)

    if content.shape[1] == 7:
        content.columns = ['timestamp','Volt','PAR','CO2','temp','logger','H2O']
    elif content.shape[1] == 6:
        content.columns = ['timestamp','CO2','PAR','temp','logger','H2O']
    else:
        print('Number of columns is unreadble.')


    content.timestamp = pd.to_datetime(content.timestamp)
    content.logger = content.logger.apply(comma_to_int)
    content.CO2 = content.CO2.apply(comma_to_float)

    
    return content



#Finds the areas of interest, by determining the lowest covariance 
#when fitting a linear fit to the areas marked by the logger signal.
#The Algorithm works as follows:
# - Triggers are found, i.e. indicies where the logger signal
#   faises or falls.
# - Starting from the first raising signal, regions between 
#   a raising and a falling edge are marked as logger areas.
# - Based on the length of the logger area the class of measurment
#   and thus the measurment length is determined. 
#   Possible classes are transparent/short or dark/long.
# - Extending the logger area on both ends by 'tolerance'
#   indicies, a search for the best linear fit is performed.
#   A fit is performed to every possible compact region of 
#   the desired measurment length within the logger area. 
#   The metric used to evaluate the quality of the fit is the
#   offdiagonal entry in the covariance matrix, squared. 
#   The lower the better.
# - A crude measure for the quality of this spicific measurment is
#   introduced. 1 if everything is fine. 2 if the measurment is short
#   thus a dark cover is used, but the CO2 have a negative slope
#   nevertheless.
# - The Results are returned.


#Parameters:
#   content: Pandas Data Frame
#   Data Frame containing the column 'logger' and 'CO2'.
#   tolerance: integer
#   The number of measurments that are included before and after 
#   the logger area, that is originally determined by the logger 
#   Signal.
#Returns:
#   markers: Pandas Data Frame
#   DataFrame with 4 columns. 
#   1. area_of_interest; 1 if part of an aoi, else 0
#   2. cover_column; class of measurment, 'd' if dark cover, 
#   't' if transparent, 
#   3.quality: 1 if good meaurment 2 if critical, (highly faulty classification)
#   4.sec_index: a number counting up for every aoi


def find_aoi(content,tolerance = 5):

    #finds the measurments
    content.logger.values[0]  = -1
    trigger = (content.logger.values[1:]-content.logger.values[:-1])
    trigger = np.sign(trigger)
    start_marks = (trigger == 1).nonzero()[0]+1
    end_marks = (trigger ==  -1 ).nonzero()[0]
    
    #resolves prolonged triggers
    d_end_marks = end_marks[1:]-end_marks[:-1]
    d_start_marks = start_marks[1:]-start_marks[:-1]
    double_end = (d_end_marks == 1).nonzero()[0]
    double_start = (d_start_marks == 1).nonzero()[0]
    end_marks = np.delete(end_marks,double_end)
    start_marks = np.delete(start_marks,double_start)
    
    #resolves initiation conflicts
    if end_marks[0]<start_marks[0]:
        end_marks = end_marks[1:]

    #selects the best measurments
    area_of_interest  = np.zeros(content.shape[0])
    quality = np.zeros(content.shape[0])
    cover_column = pd.Series(' ' for _ in range(content.shape[0]))
    sec_index = np.zeros(content.shape[0])

    
    no_measurments = np.min([len(end_marks),len(start_marks)])

    for measurment in range(no_measurments):
        best_score = 1
        
        measurment_length = end_marks[measurment]-start_marks[measurment]
        
        #if the measurment is shorter than 110 seconds
        if measurment_length < 110/5:
            cover = 't' #transparent cover
            aoi_length = int(90/5)
        else:
            cover = 'd' #dark cover
            if measurment_length < 200/5:
                aoi_length = int(180/5)
            else:
                aoi_length = int(300/5)


        #determines the start and end of the logger range, including some tolerance
        start_of_logger_area = start_marks[measurment]-tolerance
        if start_of_logger_area <0:
            start_of_logger_area = 0

        end_of_logger_area = end_marks[measurment]+tolerance-aoi_length
        if end_of_logger_area > content.shape[0]-aoi_length:
            end_of_logger_area = content.shape[0]-aoi_length
            
            
        for i in range(start_of_logger_area,end_of_logger_area):
            p,cov = np.polyfit(np.arange(aoi_length),content.CO2.values[i:i+aoi_length],1,cov = True)
            
            if cov[1][0]**2 < best_score:
                best_score = cov[1][0]**2
                best_index = i
                best_slope = p[0]

        if best_score != 1:
            area_of_interest[best_index:best_index+aoi_length+1] = 1
            cover_column[best_index:best_index+aoi_length+1] = cover
            sec_index[best_index:best_index+aoi_length+1] = 5*(np.arange(aoi_length+1))
            if cover == 'd' and best_slope < 0:
                quality[best_index:best_index+aoi_length+1] = 2
            else:
                quality[best_index:best_index+aoi_length+1] = 1

    markers = pd.DataFrame(index = content.index,
                            columns = ['area_of_interest','cover_column',
                                        'quality','sec_index'])
    

    markers['area_of_interest'] = area_of_interest
    markers['cover_column'] = cover_column
    markers['quality'] = quality
    markers['sec_index'] = sec_index
    return markers



#Writes the content and the markes Dataframe into a singe Dataframe
#and creates a .xlsx sheet from it.
#Parameters:
#   result_path: string
#   Path to where the final result should be stored
#   content: pandas Data Frame
#   Data as it is read and formated comming from the read_file function
#   markers: pandas Data Frame
#   Data Frame with the markers as created by the find_aoi function. 
def write_file(result_path,content,markers):
    

    result = pd.DataFrame(index = content.index)
    result['date'] = [x.date() for x in content.timestamp]
    result['time'] = [x.time() for x in content.timestamp]
    result['PAR'] = content.PAR
    result['CO2'] = content.CO2
    result['temperature'] = content.temp
    result['chamber'] = markers.cover_column
    result['Logger'] = content.logger
    result['sec_index'] = markers.sec_index
    result['AoI'] = markers.area_of_interest
    result['quality'] = markers.quality
    result['H2O'] = content.H2O

    writer = pd.ExcelWriter(result_path)
    result.to_excel(writer,'Sheet1')
    writer.save()
    

#Handles all the fomating once a the path has been determined.
def format_file(path_to_source,path_to_destination=None):

    print('Focusing on '+path_to_source)

    #stets the defaiult for the destination path
    if path_to_destination == None:
        path_to_destination = path_to_source[:-4]+'.xlsx'

    content = read_file(path_to_source)
    markers = find_aoi(content)
    write_file(path_to_destination,content,markers)

    print('Wrote file: '+path_to_destination)
    print('--------------------------------')

if __name__  == '__main__':

    #parses user arguments
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('source',metavar='path_to_source',
        help='path to the unfomated file/directory.')
    parser.add_argument('--destination',metavar='path_to_destination',
        help='path to the formated file/directory.')

    args = parser.parse_args()

    #assembles the paths to the files
    if os.path.isdir(args.source):
        files = []
        for file in os.listdir(args.source):
            path_to_file = os.path.join(args.source,file)
            if (os.path.isfile(path_to_file) and file[-4:] == '.txt'):
                if args.destination == None:
                    format_file(path_to_file)
                else:
                    path_to_destination = os.path.join(args.destination,file[:-4]+'.xlsx')
                    format_file(path_to_file,path_to_destination)
    else:
        if args.destination == None:
            format_file(args.source)
        else:
            path_to_destination = args.destination
            format_file(args.source,path_to_destination)


